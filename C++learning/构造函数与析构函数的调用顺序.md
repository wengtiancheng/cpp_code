## 构造函数与析构函数的调用顺序

例题与答案：

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/exam/4.png)

首先是a对象，当然是调用A类自己的构造函数，然后是C对象，先是调用基类B的构造函数，然后调用成员变量A的构造函数，最后才调用C自己的构造函数

在析构的时候，B的析构函数不是一个虚函数，然而p又是一个指向基类的指针，因此删除基类指针时指挥调用基类的虚构函数而不会调用派生类的析构函数，从而可能导致资源的泄漏。因此C类中的a实际上没有被析构

最后成员变量a调用析构函数





这一题的主要考点见下面

### **1. 构造函数和析构函数的调用顺序**

- **构造函数调用顺序**：
  - **基类先于派生类**：在创建派生类对象时，基类的构造函数总是先被调用，然后再调用派生类的构造函数。
  - **成员对象优先于类本身**：如果一个类有成员对象，在构造类对象时，会先调用成员对象的构造函数，再调用类的构造函数。
  - 在本题中：
    1. 调用 `B` 的构造函数（基类的构造函数）。
    2. 调用 `A` 的构造函数（`C` 的成员对象）。
    3. 调用 `C` 的构造函数（派生类的构造函数）。
- **析构函数调用顺序**：
  - 与构造函数调用顺序相反：析构函数的调用顺序是 **先调用派生类析构函数，再调用基类析构函数**。
  - 同时，成员对象的析构函数在类本身的析构函数之后调用。
  - 在本题中，由于基类析构函数不是虚函数，析构函数调用会出现问题（见第 3 点）。

------

### **2. 多态与虚函数**

- 在 C++ 中，析构函数是否为 

  虚函数

   是多态行为的关键：

  - 如果基类的析构函数是虚函数（`virtual ~B()`），在使用基类指针删除派生类对象时，会触发正确的派生类析构函数，并完成派生类和基类的资源释放。
  - 如果基类的析构函数不是虚函数（如本题中的 `~B()`），删除基类指针时只会调用基类的析构函数，而不会调用派生类的析构函数，从而可能导致资源泄漏。

------

### **3. 对象成员的构造与析构**

- 当类中包含其他类的对象作为成员时：
  - 构造时：先构造成员对象，再构造包含该成员的类本身。
  - 析构时：先析构类本身，再析构成员对象。
  - 在本题中：
    - 构造时，`A` 是 `C` 的成员，先调用 `A` 的构造函数，再调用 `C` 的构造函数。
    - 析构时，如果 `C` 的析构函数被调用，则会在 `C` 的析构函数之后调用 `A` 的析构函数。

------

### **4. 动态内存管理与资源释放**

- new/delete 配对使用

  ：

  - 用 `new` 创建的对象，必须使用 `delete` 释放，析构函数才会被调用。

- 本题中：

  - 使用 `B *p = new C;` 创建 `C` 对象。
  - 但 `delete p;` 只会调用 `B` 的析构函数，不能释放 `C` 的资源（因为 `B` 的析构函数不是虚函数）。

------

### **5. C++ 中的内存泄漏风险**

- 如果基类的析构函数不是虚函数，使用基类指针删除派生类对象会导致：
  - **派生类析构函数无法被调用**。
  - **派生类中动态分配的资源无法释放**。
- 在本题中，由于 `B` 的析构函数不是虚函数，`delete p` 无法调用 `C` 的析构函数，因此派生类 `C` 中的成员（如 `A`）不会正确析构。