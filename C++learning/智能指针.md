## 智能指针

#include <memory>

### 1、为什么要使用智能指针

智能指针帮助程序员管理动态分配的内存，会帮我们自动释放new出来的内存，从而避免内存泄漏

问题：new出来的对象没有delete，函数就已经结束，导致内存发生泄漏

思考：如果我们分配的动态内存都交由有生命周期的对象来处理，那么在对象过期时，让它的析构函数删除指向的内存，这是一个very nice的方案

1、c++98提供了auto_ptr模版的解决方案

2、c++11增加了unique_ptr， shared_ptr 和 weak_ptr



### 2、auto_ptr

来不及写了，TODO！！！

缺点：两个指针不能指向同一个资源，复制或者赋值都会改变资源的所有权



### 3、unique_ptr

#### 特性：

1. 基于排他所有权模式：两个指针不能指向同一个资源
2. 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值
3. 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
4. 在容器中保存指针是安全的

#### 示例：

A 无法进行左值复制赋值操作，但是允许临时右值构造和赋值

```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

int main() {
    // 测试代码
    unique_ptr<string> p1(new string("I'm Li Ming!"));
    unique_ptr<string> p2(new string("I'm age 22."));

    cout << "p1:" << (p1 ? *p1 : "null") << endl;
    cout << "p2:" << (p2 ? *p2 : "null") << endl;

    // 禁止复制赋值和拷贝构造
    // p1 = p2;
    // unique_ptr<string> p3(p2);

    // 使用 move 转移所有权
    p1 = std::move(p2);

    cout << "after p1 = std::move(p2):" << endl;
    cout << "p1:" << (p1 ? *p1 : "null") << endl;
    cout << "p2:" << (p2 ? *p2 : "null") << endl;

    return 0;
}

```

运行结果

![image-20241225194100454](C:\Users\wtc\AppData\Roaming\Typora\typora-user-images\image-20241225194100454.png)

B 在STL容器中使用unique_ptr，不允许直接赋值

```cpp
vec[0] = vec[1];	/* 不允许直接赋值 */
vec[0] = std::move(vec[1]);		// 需要使用move修饰，使得程序员知道后果
```

C 支持对象数组的管理

```cpp
// 会自动调用delete [] 函数去释放内存
unique_ptr<int[]> array(new int[5]);	// 支持这样定义

```



### 4、shared_ptr

记录引用特定内存对象的智能指针数量，当复制或者拷贝时，引用计数+1，当智能指针析构时，引用计数-1，如果计数为0，代表已经没有指针指向这块内存，那么我们就释放它

#### 1、引用计数的使用

使用use_count函数可以获取当前托管指针的引用计数

```cpp
shared_ptr<Person> sp1;

shared_ptr<Person> sp2(new Person(2));

// 获取智能指针管控的共享指针的数量	use_count()：引用计数
cout << "sp1	use_count() = " << sp1.use_count() << endl;
cout << "sp2	use_count() = " << sp2.use_count() << endl << endl;

// 共享
sp1 = sp2;

cout << "sp1	use_count() = " << sp1.use_count() << endl;
cout << "sp2	use_count() = " << sp2.use_count() << endl << endl;

shared_ptr<Person> sp3(sp1);
cout << "sp1	use_count() = " << sp1.use_count() << endl;
cout << "sp2	use_count() = " << sp2.use_count() << endl;
cout << "sp2	use_count() = " << sp3.use_count() << endl << endl;

```

开始的时候sp1是一个空的shared_ptr，没有关联任何动态分配的对象，因此sp1.use_count()的值为0，后来sp1和sp2共同管理一个对象，因此引用计数才变为2

#### 2、构造和初始化

这部分感觉文章讲的稍乱，自己整理了一下



## **`shared_ptr`**

### **初始化**

1. **通过`std::make_shared`：推荐**

   ```
   cpp
   
   
   复制代码
   std::shared_ptr<int> sp1 = std::make_shared<int>(10);
   ```

   - 高效地分配内存并初始化对象。

2. **通过`new`分配对象：**

   ```
   cpp
   
   
   复制代码
   std::shared_ptr<int> sp2(new int(20));
   ```

   - **不推荐**，因为 `make_shared` 性能更优，且更安全。

3. **从另一个`shared_ptr`复制：**

   ```
   cpp
   
   
   复制代码
   std::shared_ptr<int> sp3 = sp1;
   ```

   - 增加引用计数。

4. **从`unique_ptr`转换：**

   ```
   cpp复制代码std::unique_ptr<int> up = std::make_unique<int>(30);
   std::shared_ptr<int> sp4 = std::move(up);
   ```

   - 转换后，`unique_ptr` 不再拥有对象。

------

### **删除**

1. 自动删除：

   - 当最后一个 `shared_ptr` 离开作用域或被赋值为 `nullptr` 时，管理的对象会自动销毁。

2. 手动重置：

   ```
   cpp复制代码sp1.reset(); // 对象被销毁，sp1 置为空
   sp2.reset(new int(40)); // sp2 指向新的对象
   ```

------

### **常用 API**

- `use_count()`

  : 返回当前引用计数。

  ```
  cpp
  
  
  复制代码
  std::cout << sp1.use_count() << std::endl;
  ```

- `get()`

  : 返回原始指针，但不影响引用计数。

  ```
  cpp
  
  
  复制代码
  int* raw_ptr = sp1.get();
  ```

- `reset()`

  : 释放当前指向的对象。

  ```
  cpp
  
  
  复制代码
  sp1.reset();
  ```

- `swap()`

  : 交换两个 

  ```
  shared_ptr
  ```

   的内容。

  ```
  cpp
  
  
  复制代码
  sp1.swap(sp2);
  ```

------

## **`unique_ptr`**

### **初始化**

1. **通过`std::make_unique`：推荐**

   ```
   cpp
   
   
   复制代码
   std::unique_ptr<int> up1 = std::make_unique<int>(50);
   ```

2. **通过`new`分配对象：**

   ```
   cpp
   
   
   复制代码
   std::unique_ptr<int> up2(new int(60));
   ```

3. **从另一个`unique_ptr`移动：**

   ```
   cpp
   
   
   复制代码
   std::unique_ptr<int> up3 = std::move(up1);
   ```

   - `up1` 失去对对象的所有权。

------

### **删除**

1. **自动删除：**

   - 当 `unique_ptr` 离开作用域时，其管理的对象会自动销毁。

2. **手动重置：**

   ```
   cpp复制代码up2.reset(); // 对象被销毁，up2 置为空
   up3.reset(new int(70)); // up3 指向新的对象
   ```

------

### **常用 API**

- `get()`

  : 返回原始指针。

  ```
  cpp
  
  
  复制代码
  int* raw_ptr = up1.get();
  ```

- `reset()`

  : 释放当前指向的对象。

  ```
  cpp
  
  
  复制代码
  up1.reset();
  ```

- `release()`

  : 释放所有权，返回原始指针，不会销毁对象。

  ```
  cpp
  
  
  复制代码
  int* raw_ptr = up2.release();
  ```

- `swap()`

  : 交换两个 

  ```
  unique_ptr
  ```

   的内容。

  ```
  cpp
  
  
  复制代码
  up1.swap(up2);
  ```

------

## **比较**

| 特性       | `shared_ptr`           | `unique_ptr`       |
| ---------- | ---------------------- | ------------------ |
| 拥有者数量 | 多个共享管理一个对象   | 唯一管理一个对象   |
| 引用计数   | 有引用计数             | 没有引用计数       |
| 转移所有权 | 支持复制和移动         | 只支持移动         |
| 适用场景   | 对象需要多个共享所有者 | 对象仅有一个所有者 |
| 性能       | 引用计数略有性能开销   | 性能略优           |
| 推荐初始化 | `std::make_shared`     | `std::make_unique` |

