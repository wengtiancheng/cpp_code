## 重载

在C++中，运算符重载是一个重要的特性，但也需要注意一些关键点和常见的陷阱。以下是运算符重载需要注意的知识点：

------

### **1. 运算符重载的限制**

- **不能重载的运算符**： C++ 中有一些运算符是无法重载的，包括：
  - `::`（作用域解析运算符）
  - `.`（成员访问运算符）
  - `.*`（成员指针访问运算符）
  - `sizeof`（求大小运算符）
  - `typeid`（类型信息运算符）
  - `alignof`（对齐要求运算符）
- **不能改变运算符的优先级或结合性**： 重载只改变行为，运算符的优先级和结合性是固定的。

------

### **2. 成员函数 vs 全局函数**

- 成员函数

  ：

  - 左操作数必须是当前类的对象。
  - 通常适用于一元运算符（如 `+`、`-`、`++`、`--`）和赋值运算符（如 `=`、`+=`、`-=`）。

- 全局函数

  ：

  - 可以让左右操作数都不属于当前类。
  - 通常适用于需要支持隐式转换的运算符（如 `+`、`==`、`<` 等）。
  - 如果需要访问类的私有或保护成员，必须通过友元实现。

**示例**：

```cpp
class Complex {
    int real, imag;
public:
    Complex(int r = 0, int i = 0) : real(r), imag(i) {}

    // 成员函数实现
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // 全局函数实现
    friend Complex operator-(const Complex& c1, const Complex& c2) {
        return Complex(c1.real - c2.real, c1.imag - c2.imag);
    }
};
```

------

### **3. 避免二义性**

当同时定义成员函数和全局函数时，可能会导致编译器无法决定使用哪个版本，从而产生二义性。例如：

```cpp
class A {
public:
    A operator+(const A& other) const; // 成员函数
};

A operator+(const A& lhs, const A& rhs); // 全局函数
```

**解决方法**：尽量保持一致性，根据需求选择成员函数或全局函数的一种实现方式即可。

------

### **4. 常用的运算符重载**

- **一元运算符**：通常是成员函数。

  - `+`、`-`（正负号）
  - `++`、`--`（前置/后置递增递减）

  **注意**：后置形式的 `++` 和 `--` 重载需要一个额外的 `int` 参数，用于区分前置和后置。

  ```cpp
  class Counter {
      int value;
  public:
      Counter(int v = 0) : value(v) {}
  
      // 前置++
      Counter& operator++() {
          ++value;
          return *this;
      }
  
      // 后置++
      Counter operator++(int) {
          Counter temp(*this);
          ++value;
          return temp;
      }
  };
  ```

- **二元运算符**：

  - `+`、`-`、`*`、`/` 等常见运算符。
  - 赋值类运算符如 `+=`、`-=` 等一般重用基本的二元运算符。

- **比较运算符**：

  - `==`、`!=`、`<`、`>` 等通常通过全局函数实现。

  - 可以使用标准库的 

    ```
    std::tie
    ```

     来简化实现：

    ```
    bool operator<(const Complex& other) const {
        return std::tie(real, imag) < std::tie(other.real, other.imag);
    }
    ```

- **流插入与提取运算符**：必须定义为全局函数，并通过友元访问类的私有成员。

  ```
  friend std::ostream& operator<<(std::ostream& os, const Complex& c) {
      os << "(" << c.real << ", " << c.imag << ")";
      return os;
  }
  ```

------

### **5. 常量性与引用**

- 对于不修改对象的运算符，尽量在函数末尾添加 `const`，表示它不会修改调用对象：

  ```
  Complex operator+(const Complex& other) const; // 不修改当前对象
  ```

- 尽量返回值的常量引用或新对象，避免额外的拷贝：

  ```cpp
  const Complex& operator+=(const Complex& other);
  ```

------

### **6. 自定义赋值运算符**

- 如果类中包含动态内存（如指针成员），需要自定义赋值运算符以避免浅拷贝问题。赋值运算符的标准实现包括

  自赋值检查

  和

  深拷贝

  。

  ```cpp
  class MyClass {
      int* data;
  public:
      MyClass(int value) : data(new int(value)) {}
      ~MyClass() { delete data; }
  
      MyClass& operator=(const MyClass& other) {
          if (this != &other) { // 自赋值检查
              delete data;      // 清理旧资源
              data = new int(*other.data); // 深拷贝
          }
          return *this;
      }
  };
  ```

------

### **7. 性能和安全性**

- 使用`std::move`优化返回值避免不必要的拷贝：

  ```
  Complex operator+(Complex&& other) const {
      return std::move(Complex(real + other.real, imag + other.imag));
  }
  ```

- 避免在函数内创建临时对象的过多开销。

------

### **总结**

运算符重载是C++的一个强大特性，但需要注意以下几点：

1. 确保运算符的语义符合实际运算逻辑。
2. 合理选择成员函数或全局函数。
3. 注意返回值的类型和效率问题。
4. 避免二义性，尽量统一风格。
5. 对于涉及动态内存管理的类，需特别处理赋值运算符和拷贝构造函数。

掌握这些知识点后，你将能够在实际项目中更高效、安全地使用运算符重载！





## 运算符重载的返回值类型

### 1、根据运算符的语义

例如赋值运算符返回被调用对象的引用

算数运算符返回一个新的对象

输入输出运算符返回ostream或者istream

**递增递减运算符：如果是前置形式（++a)，就是先加后返回，那么就是返回调用对象的引用*this；如果是后置形式(a++)，返回原始对象的副本，这样在原始对象增加之后，副本还是会保持原来的值，这里设计深拷贝和浅拷贝中常量的知识，等会再整理**

```cpp
class Counter {
public:
    Counter& operator++() { // 前置++
        ++value;
        return *this; // 返回当前对象的引用
    }

    Counter operator++(int) { // 后置++
        Counter temp = *this; // 保存当前状态
        ++value;
        return temp; // 返回原始对象的副本
    }
};

```

