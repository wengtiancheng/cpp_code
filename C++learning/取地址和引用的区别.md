## 取地址和引用的区别

### 1. **取地址符号（Address-of operator）**

`&`作为**取地址符号**时，用于获取变量在内存中的地址，返回一个指针。

#### 示例：

```
cpp复制代码int x = 10;
int *p = &x;  // 取x的地址，赋值给指针p
```

- `&x`：取变量`x`的地址，返回`x`在内存中的地址。
- `p`是一个指针，存储了`x`的地址。

------

### 2. **引用符号（Reference declaration operator）**

`&`作为**引用符号**时，用于声明一个变量的引用。引用是一个现有变量的别名，操作引用变量时直接影响其指向的对象。

#### 示例：

```
cpp复制代码int x = 10;
int &r = x;  // r是x的引用
r = 20;      // 修改r的值，相当于修改x的值
```

- `int &r`：声明`r`是`x`的引用，`r`和`x`指向的是同一块内存。
- 修改`r`，会直接修改`x`。

------

### 3. 区别与联系

| 用途         | 符号形式 | 含义                                | 返回类型         |
| ------------ | -------- | ----------------------------------- | ---------------- |
| **取地址**   | `&x`     | 返回变量的地址                      | 指针（如`int*`） |
| **声明引用** | `int &r` | 声明`r`是变量的引用，`r`是`x`的别名 | 与被引用变量一致 |

**它们的区别：**

- **取地址**：用来操作内存地址，返回指针。
- **引用**：用来创建别名，直接操作引用变量会影响原始变量。

------

### 4. 混合使用示例

两种用法可以结合在一起：

```
cpp复制代码int x = 10;
int &r = x;     // r是x的引用
int *p = &r;    // 取r的地址，实际上是取x的地址

std::cout << "x: " << x << std::endl;        // 输出10
std::cout << "r: " << r << std::endl;        // 输出10
std::cout << "*p: " << *p << std::endl;      // 输出10
std::cout << "地址: " << &x << " == " << p << std::endl;  // 两者相等
```

输出结果说明：

- `r`是`x`的引用，所以`&r`和`&x`返回的是相同的地址。
- 指针`p`存储了`x`的地址，通过`*p`可以访问`x`的值。

------

### 5. 多态和基类引用的例子

引用和取地址结合在继承关系中时可以触发多态机制。例如：

```
cpp复制代码class A {
public:
    virtual void show() { std::cout << "A" << std::endl; }
};

class B : public A {
public:
    void show() override { std::cout << "B" << std::endl; }
};

int main() {
    B b;
    A &r_a = b;         // 基类引用引用派生类对象
    A *p_a = &r_a;      // 取r_a的地址，指针p_a指向b

    r_a.show();         // 输出：B
    p_a->show();        // 输出：B

    return 0;
}
```

- **`A &r_a = b;`**：基类引用`r_a`引用派生类对象`b`。
- **`A \*p_a = &r_a;`**：取`r_a`的地址，实际上是`b`的地址，`p_a`指向了`b`。
- 调用`show()`方法时，触发虚函数机制，调用`B`类的实现。

------

### 6. 总结

- `&`符号既可以表示取地址，也可以用于声明引用。
- **取地址**：返回变量的内存地址，返回的是一个指针。
- **引用**：为变量创建别名，操作引用等同于操作原变量。
- 理解关键在于语境：是作为操作符使用，还是作为声明符使用。