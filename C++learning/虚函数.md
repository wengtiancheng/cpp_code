## 虚函数

### 1.  类型相容

问题：a和b都是类，a和b是什么类型的时候，a = b 合法（赋值相容）？

答：b是a的子类型的时候， A a; B b; class B : public A



基类的引用和指针可以引用或指向派生类对象，或者说可以让父类指向子类

```c++
class A{
public:
    void f();
}

class B : public A{
public:
    void f();
    void g();
}

A a;
B b;
a = b; //ok
b = a; //error
a.f(); // A::f()

//基类的指针或者引用可以指向或者引用派生类对象
A &r_a = b;
A *p_a = &b; //all OK，反过来就不行

//以下两个部分基本是一致的
func1(A& a){a.f();}
func2(A *pa){pa->f();}
func1(b);//A::f
func2(&b);
```



**关于为什么func1(b)调用的是A的成员函数：**

对象切片。当一个派生类对象被赋值给一个基类对象的时候，会发生对象切片，派生类中独有的部分会被舍弃，而共享的部分都会被转化为基类的内容。



### 2. 绑定时间

- 前期绑定（静态绑定）

  - 编译时刻确定调用哪一个方法
  - 依据对象的静态类型
  - 效率高、灵活性差
  - 静态绑定根据形参决定

- 动态绑定

  1. 晚绑定是指编译器或者解释器在运行前不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。
  2. c++中晚绑定常常发生在使用`virtual`声明成员函数
  3. 运行时刻确定，依据对象的实际类型(动态)
  4. 灵活性高、**效率低**
  5. 动态绑定函数也就是虚函数。
  6. 直到构造函数返回之后，对象方可正常使用
  7. C++默认的都是静态绑定，Java默认的都是动态绑定

  人工刚刚

  

  

### 3. 虚函数的定义

**定义：**虚函数是指一个类中你希望重载的成员函数，当你使用一个基类指针指向一个继承类对象的时候，调用一个虚函数时，实际调用的是继承类的版本



**注意：**如果基类中已经被定义为虚函数了，那么派生类中对这个函数重定义的时候，可以不再加virtual



**举例子：**

```c++
class A{
public:
    
    virtual void f();
    void g();
}

class B : public A{
public:
    void f();
    void g();
}

B b;
A* p = &b;

p->f(); // B::f()
p->g(); // A::g()
```



### 4. 防止出错

- final

  如果不希望某个类被继承，或不希望某个虚函数被重写，则可以在类名和虚函数后加上 final 关键字，加上 final 关键字后，再被继承或重写，编译器就会报错。

  ```cpp
  class Base {
  public:
      virtual void Show(int x) final; // 虚函数
  };
   
  class Derived : public Base {
  public:
      virtual void Show(int x) override; // 重写提示错误  
  };
  ```

  

- override

  派生类中加override，明确表示派生类中的函数是重写基类的，如果派生类与基类的函数名、参数列表、const属性不一致，就会报错

  ```cpp
  class Base {
  public:
      virtual void Show(int x); // 虚函数
  };
   
  class Derived : public Base {
  public:
      virtual void Show(int x) const override; // const 属性不一样，新的虚函数 
  };
  ```

  



### 5. 其他考点

1. 类的成员函数才可以是虚函数:全局函数不可以是虚函数
2. 静态成员函数不能是虚函数:静态的成员函数属于类，并不属于一个对象，所以不能虚函数
3. 内联成员函数不能是虚函数:内联成员函数在编译的时候就已经确定了
4. 构造函数不能是虚函数:
   1. 因为创建类的时候是自动调用的，父类的指针无法直接调用，虚函数没有意义
   2. 虚函数表是在构造函数中完成的
5. 析构函数可以(往往)是虚函数
   1. 如果不是虚函数，不好调用到派生类中的析构函数(delete一个父类指针，如果非虚，不能调用到派生类的析构函数)



















## 